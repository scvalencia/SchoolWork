%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Plantilla para un artículo en LaTeX en español.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\documentclass{article}

% Esto es para poder escribir acentos directamente:
\usepackage[latin1]{inputenc}
% Esto es para que el LaTeX sepa que el texto está en español:
\usepackage[spanish]{babel}

% Paquetes de la AMS:
\usepackage{amsmath, amsthm, amsfonts, mathtools}
\usepackage{multicol}

\DeclarePairedDelimiter{\ceil}{\lceil}{\rceil}

% Teoremas
%--------------------------------------------------------------------------
\newtheorem{thm}{Teorema}[section]
\newtheorem{cor}[thm]{Corolario}
\newtheorem{lem}[thm]{Lema}
\newtheorem{prop}[thm]{Proposición}
\theoremstyle{definition}
\newtheorem{defn}[thm]{Definición}
\theoremstyle{remark}
\newtheorem{rem}[thm]{Observación}

% Atajos.
% Se pueden definir comandos nuevos para acortar cosas que se usan
% frecuentemente. Como ejemplo, aquí se definen la R y la Z dobles que
% suelen representar a los conjuntos de números reales y enteros.
%--------------------------------------------------------------------------

\def\RR{\mathbb{R}}
\def\ZZ{\mathbb{Z}}

% De la misma forma se pueden definir comandos con argumentos. Por
% ejemplo, aquí definimos un comando para escribir el valor absoluto
% de algo más fácilmente.
%--------------------------------------------------------------------------
\newcommand{\abs}[1]{\left\vert#1\right\vert}

% Operadores.
% Los operadores nuevos deben definirse como tales para que aparezcan
% correctamente. Como ejemplo definimos en jacobiano:
%--------------------------------------------------------------------------
\DeclareMathOperator{\Jac}{Jac}

%--------------------------------------------------------------------------
\title{Diseño y análisis de algoritmos. Tarea I}
\author{Sebastián Valencia Calderón\\
  \small 201111578
}

\begin{document}
\maketitle

\begin{enumerate}
  \item El lenguaje GCL, elegido para expresar los algoritmos del curso, tiene peculiaridades que no son corrientes en los lenguajes de programación comerciales. Dé respuesta a las siguientes preguntas. 
  \begin{enumerate}
    \item Suponga que GCL se enriquice con una instrucción nueva $S$, pero que ésta se puede implementar con intrucciones GCL ya conocidas. ¿Es factible enriquecer el cálculo de Hoare con una regla que permita concluir la corrección de $S$ con respecto a la especificación dada?
    
    \item Dado dos programas $S_{1}$ y $S_{2}$, se dice que $S_{1}$ simula $S_{2}$ cuando para toda especificación $Q, R$ se tiene que:
    
    $$\left\{Q \right\} \ S_{2} \left\{R \right\} \Rightarrow \left\{Q \right\} \ S_{1} \left\{R \right\}$$
    
    Defina la relación \\
    $$Equivale(S_{1}, S_{2}) \iff Simula(S_{1}, S{2})\ \wedge\ Simula(S_{2}, S_{1})$$ 
    Muestre que $Equivale$ es una relación de equivalencia. Explique en términos operacionales cuando dos programas son equivalentes. \\
    
    Una relación es de equivalencia, sí y sólo si ésta es refelxiva, simétrica y transitiva. Para saber si la relación $Equivale$ es una relación de equivalencia, es necesario mostrar si satisface éstas tres propiedades.
    
    Comenzamos por la reflexividad, $Equivale$ es refelxiva sí y sólo si:    
    $$\forall\ S : Equivale(S,\ S) = Simula(S, S)\ \wedge\ Simula(S, S) = Simula(S, S)$$
     $$Simula(S, S)= \left\{Q \right\} \ S \left\{R \right\} \Rightarrow \left\{Q \right\} \ S \left\{R \right\} = True$$ 
    
    luego, la relación es reflexiva. Ahora se desa probar simétria. $Equivale$ es simétrica sí y sólo si $\forall\ S, T : Equivale(S,\ T) = Equivale(T,\ S)$
    $$Equivale(S,\ T) = Simula(S, T)\ \wedge\ Simula(T, S)$$ 		
    $$Simula(S, T)\ \wedge\ Simula(T, S) = Simula(T, S)\ \wedge\ Simula(S, T)$$
    $$Simula(T, S)\ \wedge\ Simula(S, T) = Equivale(T,\ S)$$
    
    con ésto, se prueba simetría. Falta probar transitividad, es decir, Equivale es transitiva, únicamente si: 
    $$Equivale(S,\ T) \wedge Equivale(T,\ U)\Rightarrow Equivale(S,\ U)$$
    $$Simula(S, T)\ \wedge\ Simula(T, S) \wedge Simula(T, U)\ \wedge\ Simula(U, T)$$
    
  \end{enumerate}
  \item Dadas las funciones de variable real positiva, ordénelas en una secuencia tal que $f_{i} = O(f_{i + 1})$ para $i \in [1, 8]$.
  
  \begin{multicols}{2}
\begin{enumerate}
    \item $$\log(\ceil n )$$
    \item $$n!$$
    \item $$\sum_{k = 1}^{n} \frac{k}{2^k}$$
    \item $$3^{\log(n)}$$
    \item $$n^\pi$$
    \item $$\left(\frac{e}{2}\right)^n$$
    \item $$\left(\frac{e}{3}\right)^n$$
    \item $$\prod_{k=1}^{\log \lfloor n \rfloor} \frac{k}{2^k}$$
\end{enumerate}
\end{multicols}
  \item Dada una matriz de enteros $A[0 .. m -1, 0 ..n -1]$, donde cada fila está oprdenada ascendentemente, y un entero $x \in \mathbb{Z}$, se quiere saber si $x \in A$. Para ésto, se usa la función $busa$, a su vez, dentro del cuerpo de $busa$ se llama $busbin$.
\end{enumerate}

% Bibliografía.
%-----------------------------------------------------------------


\end{document}